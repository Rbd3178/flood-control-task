# Ход решения 
Так как в задании требуется предусмотреть общее хранилище данных для нескольких экземпляров приложения, сначала определился с выбором базы данных. Нужно хранить данные в виде "ключ-значение", при этом важно быстродействие. Поэтому выбрал Redis. Уже позже прочитал про нежурналируемые таблицы (unlogged tables) в PostgreSQL, которые предлагают cхожую производительность, но реализация мне показалась сложнее, и для решения данной задачи не увидел особых преимуществ, поэтому свой выбор не изменил.

Затем продумал сам алгоритм. Выбрал такой вариант, так как он по моему мнению лучше всего отвечает требованию "Если за последние N секунд вызовов больше K, проверка не пройдена": ключ - userID, по нему храним счетчик вызовов. При вызове метода Check если счетчик меньше K, увеличиваем его на 1. При этом запускаем goroutine которая через N секунд уменьшит этот счетчик на 1. Таким образом, счетчик всегда хранит количество вызовов в последние N секунд. Также при увеличении счетчика вызываем команду Expire, это нужно, чтобы даже если что-то случилось и горутины которые отвечали за уменьшение счетчика не выполнились, то по прошествии K секунд с последнего запроса он все равно обнулился. Был и другой вариант - вызывать expire только при увеличении счетчика с 0 до 1, не уменьшать счетчик отдельно. Тогда в течении N секунд с первого вызова можно сделать еще K - 1 вызов которые вернут true, потом счетчик обнуляется. Этот вариант проще и не использует горутины, но позволяет сделать 2 * K - 1 вызов за короткое время: K - 1 прямо перед прошествием N секунд после первого увеличения счетчика, и еще K сразу же после его обнуления. Поэтому решил реализовать первый вариант.

В самой реализации также есть возможность конфигурации. В файле config.go хранится структура `Config`, в которой хранятся данные для подключения к БД и параметры контроля - длительность временного промежутка и лимит вызовов. Данные в структуру можно передать из файлов .toml и .json, пример для первого варианта в функции `setupControl()` в main.go.

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
